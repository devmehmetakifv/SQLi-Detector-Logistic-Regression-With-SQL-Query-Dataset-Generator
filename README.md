# SQL Injection Detection System

A comprehensive machine learning-based SQL Injection (SQLi) detection system featuring a sophisticated synthetic query generator, multi-generation model training, and robust evaluation framework.

## ğŸ¯ Project Overview

This project implements an end-to-end pipeline for detecting SQL injection attacks using machine learning. The system generates synthetic training data, trains classification models, and provides tools for comprehensive model evaluation and comparison.

### Key Features

- **Synthetic Query Generator**: Produces millions of diverse benign and malicious SQL queries
- **Automated Dataset Splitting**: 80/10/10 train/test/validation splits with unique random seeds
- **Multi-Generation Training**: Track model evolution across training iterations
- **Comprehensive Evaluation**: Category-level analysis, confusion matrices, and false positive/negative tracking
- **Zero False Negative Design**: Prioritizes catching all attacks (100% recall)

## ğŸ“Š Model Performance

### Generation Comparison

| Metric | Gen 1 | Gen 2 | Gen 3 |
|--------|-------|-------|-------|
| **Accuracy** | 60.31% | 82.12% | 83.69% |
| **Precision** | 55.41% | 73.39% | 75.15% |
| **Recall** | 100% | 100% | 100% |
| **F1 Score** | 71.31% | 84.65% | 85.81% |
| **ROC-AUC** | 0.9946 | 0.9973 | 0.9975 |

> **Note**: 100% recall means zero false negatives â€” no malicious query escapes detection.

## ğŸ—‚ï¸ Project Structure

```
sql_query_generator/
â”œâ”€â”€ sql_query_generator/
â”‚   â””â”€â”€ sql_query_generator.py    # Core synthetic query generator
â”œâ”€â”€ dataset/
â”‚   â”œâ”€â”€ train/
â”‚   â”‚   â”œâ”€â”€ benign.txt            # 80% training benign queries
â”‚   â”‚   â””â”€â”€ malicious.txt         # 80% training malicious queries
â”‚   â”œâ”€â”€ test/
â”‚   â”‚   â”œâ”€â”€ benign.txt            # 10% test benign queries
â”‚   â”‚   â”œâ”€â”€ malicious.txt         # 10% test malicious queries
â”‚   â”‚   â””â”€â”€ evaluation_set.csv    # Hand-crafted evaluation dataset
â”‚   â””â”€â”€ val/
â”‚       â”œâ”€â”€ benign.txt            # 10% validation benign queries
â”‚       â””â”€â”€ malicious.txt         # 10% validation malicious queries
â”œâ”€â”€ generations/
â”‚   â”œâ”€â”€ 1st_train_session/        # First generation model/vectorizer
â”‚   â”œâ”€â”€ 2nd_train_session/        # Second generation model/vectorizer
â”‚   â””â”€â”€ 3rd_train_session/        # Third generation model/vectorizer
â”œâ”€â”€ evaluations/                   # Evaluation results and comparisons
â”œâ”€â”€ train_sqli_detector.ipynb     # Model training notebook
â”œâ”€â”€ evaluate_models.ipynb          # Multi-generation evaluation notebook
â””â”€â”€ README.md
```

## ğŸš€ Quick Start

### Prerequisites

```bash
pip install scikit-learn pandas numpy matplotlib seaborn joblib
```

### Generate Training Data

Generate a dataset with automatic 80/10/10 train/test/val split:

```bash
# Generate 1 million queries per class (2M total)
python sql_query_generator/sql_query_generator.py 1000000
```

This creates:
- **Train**: 800,000 benign + 800,000 malicious queries
- **Test**: 100,000 benign + 100,000 malicious queries  
- **Val**: 100,000 benign + 100,000 malicious queries

### Alternative: Generate Specific Query Types

```bash
# Generate only benign queries
python sql_query_generator.py --benign -n 50000 -o benign_queries.txt

# Generate only malicious queries  
python sql_query_generator.py --malicious -n 50000 -o malicious_queries.txt
```

### Train a Model

Open and run `train_sqli_detector.ipynb` to:
1. Load training data from `dataset/train/`
2. Fit a TF-IDF vectorizer
3. Train a classification model
4. Evaluate on test/validation sets
5. Save model artifacts

### Evaluate Models

Open and run `evaluate_models.ipynb` to:
1. Compare multiple model generations
2. Analyze per-category performance
3. Identify false positives/negatives
4. Generate visualizations

## ğŸ”§ Query Generator Details

### Benign Query Categories

The generator produces diverse benign SQL patterns including:

| Category | Count | Examples |
|----------|-------|----------|
| **SELECT** | ~600+ templates | Simple queries, JOINs, subqueries |
| **INSERT/UPDATE/DELETE** | ~50+ templates | CRUD operations |
| **ORDER BY** | ~70 templates | Single/multi-column sorting |
| **Aggregate Functions** | ~50+ templates | COUNT, SUM, AVG, MIN, MAX |
| **Window Functions** | ~15 templates | ROW_NUMBER, RANK, LAG, LEAD |
| **CTEs** | ~5 templates | WITH clause patterns |
| **JSON Operations** | ~10 templates | JSON_EXTRACT, JSON_OBJECT |
| **Admin Commands** | ~100+ templates | SHOW, DESCRIBE, EXPLAIN |
| **Edge Cases** | ~50+ templates | Keywords in string literals |

### Malicious Query Categories

Injection patterns are generated by applying payloads to benign queries:

- **UNION-based**: Data exfiltration via UNION SELECT
- **Error-based**: Extracting data through error messages
- **Boolean Blind**: True/false inference attacks
- **Time-based Blind**: SLEEP/BENCHMARK delays
- **Stacked Queries**: Multiple statement execution
- **Comment Injection**: SQL comment exploitation

### Query Distribution

The generator maintains a balanced distribution:
- **75%** SELECT queries (including simple queries)
- **7%** INSERT queries
- **5%** UPDATE queries
- **13%** Hard negative patterns (edge cases)

## ğŸ“ˆ Training Pipeline

### Feature Extraction

Uses TF-IDF vectorization with:
- **Max Features**: 15,000 n-grams
- **N-gram Range**: (2, 5) character n-grams
- **Sublinear TF**: Enabled for large datasets

### Model Architecture

The default model is a **Logistic Regression** classifier with:
- L2 regularization
- Balanced class weights
- High tolerance for convergence

### Training Statistics (Gen 3)

- **Training samples**: 1,600,000 queries
- **Vocabulary size**: 15,000 n-grams
- **TF-IDF fitting time**: ~8.5 minutes
- **Model training time**: ~5 minutes

## ğŸ§ª Evaluation Framework

### Evaluation Dataset

A hand-crafted `evaluation_set.csv` containing ~510 queries across 60+ categories:
- Real-world benign patterns
- Known SQLi attack patterns
- Edge cases and ambiguous queries

### Metrics Tracked

- **Accuracy**: Overall correct classification rate
- **Precision**: True positives / All predicted positives
- **Recall**: True positives / All actual positives
- **F1 Score**: Harmonic mean of precision and recall
- **ROC-AUC**: Area under the ROC curve

### Category-Level Analysis

The evaluation identifies:
- **Best performing categories**: Usually malicious patterns (100% accuracy)
- **Worst performing categories**: Complex JOINs, minimal queries, edge cases

## ğŸ¯ Known Limitations & Future Work

### Current False Positive Hotspots

| Category | Accuracy | Reason |
|----------|----------|--------|
| `join` | 28.57% | Complex JOIN patterns look suspicious |
| `complex_benign` | 32.73% | Multi-feature queries trigger detection |
| `minimal` | 36.36% | VERSION(), DATABASE() functions |
| `edge_case` | 54.76% | Keywords in legitimate string data |

### Improvement Opportunities

1. **More JOIN templates**: Expand coverage of complex JOIN patterns
2. **Meta-query patterns**: Add more database utility function examples
3. **Contextual features**: Beyond TF-IDF (parenthesis balance, keyword positions)
4. **Ensemble methods**: Combine multiple classifiers

## ğŸ“ API Reference

### Generator CLI

```bash
python sql_query_generator.py <total_per_class>
python sql_query_generator.py --benign|--malicious -n <count> [-o <output_file>]
```

### Programmatic Usage

```python
from sql_query_generator import generate_queries, generate_one_benign, generate_one_malicious

# Generate specific query types
benign_queries = generate_queries("benign", 1000)
malicious_queries = generate_queries("malicious", 1000)

# Generate single queries
single_benign = generate_one_benign()
single_malicious = generate_one_malicious()
```

## ğŸ“„ License

This project is provided for educational and research purposes.

## ğŸ™ Acknowledgments

- Built with scikit-learn, pandas, and matplotlib
- Inspired by real-world SQLi attack patterns from OWASP
- Developed through iterative improvement based on evaluation feedback
